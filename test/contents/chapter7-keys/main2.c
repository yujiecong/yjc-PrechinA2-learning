/*************************************************************************************

*
实验现象：下载程序后数码管显示0，按下矩阵按键上的按键显示对应的数字
		 
注意事项：										

										  
**************************************************************************************

*/
#include "reg52.h" //此文件中定义了单片机的一些特殊功能寄存器

typedef unsigned int u16; //对数据类型进行声明定义
typedef unsigned char u8;

#define GPIO_DIG P0
#define GPIO_KEY P1

u8 KeyValue; //用来存放读取到的键值

u8 code smgduan[17] = {0xc0, 0xf9, 0xa4, 0xb0, 0x99, 0x92, 0x82, 0xf8,
                       0x80, 0x90, 0x88, 0x83, 0xc6, 0xa1, 0x86, 0x8e}; //显示0~F的值

/*******************************************************************************
* 函 数 名         : delay
* 函数功能		   : 延时函数，i=1时，大约延时10us
*******************************************************************************/
void delay(u16 i)
{
    while (i--)
        ;
}
char pow(char i)
{
    char j, l = 1;
    for (j = 0; j < i; j++)
        l *= 2;
    return l;
}
/*******************************************************************************
* 函 数 名         : KeyDown
* 函数功能		   : 检测有按键按下并读取键值
* 输    入         : 无
* 输    出         : 无

逐行扫描：我们可以通过高四位轮流输出低电平来对矩阵键盘进行逐行扫描，当低四位接收到的数据不全为1的时候，说明有按键按下，然后通过接收到的数据是哪一位为0来判断是哪一个按键被按下。
*******************************************************************************/
void KeyDown(void)
{
    char a = 0;
    char line, temp = 0x0f;
    GPIO_KEY = 0x0f;

    //对高4位轮流输出
    for (line = 0; line < 4; line++)
    {

        if (GPIO_KEY != temp) //读取按键是否按下
        {
            temp = GPIO_KEY + pow(line + 4);
            GPIO_KEY += pow(line + 4);
            delay(1000);          //延时10ms进行消抖
            if (GPIO_KEY != temp) //再次检测键盘是否按下
            {

                switch (GPIO_KEY pow(line + 4))
                {
                case (0Xf7):
                    KeyValue = 0;
                    break;
                case (0Xfb):
                    KeyValue = 1;
                    break;
                case (0Xfd):
                    KeyValue = 2;
                    break;
                case (0Xfe):
                    KeyValue = 3;
                    break;
                }
                KeyValue += (line * 4);
                
                break;
            }
        }
        else
        {
            delay(100);
        }
        

    }
    	while((a<50)&&(GPIO_KEY!=0xf0))	 //检测按键松手检测
	{
		delay(100);
		a++;
	}

}

/*******************************************************************************
* 函 数 名       : main
* 函数功能		 : 主函数
* 输    入       : 无
* 输    出    	 : 无
*******************************************************************************/
void main()
{

    while (1)
    {
        KeyDown();                     //按键判断函数
        GPIO_DIG = ~smgduan[KeyValue]; //
    }
}
